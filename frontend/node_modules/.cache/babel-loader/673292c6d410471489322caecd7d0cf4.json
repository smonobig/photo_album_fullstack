{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n  if (typeof window === 'undefined') return;\n  function isTransitionEvent(event) {\n    return 'propertyName' in event;\n  }\n  let onTransitionStart = e => {\n    if (!isTransitionEvent(e) || !e.target) return;\n    // Add the transitioning property to the list for this element.\n    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener('transitioncancel', onTransitionEnd, {\n        once: true\n      });\n    }\n    transitions.add(e.propertyName);\n  };\n  let onTransitionEnd = e => {\n    if (!isTransitionEvent(e) || !e.target) return;\n    // Remove property from list of transitioning properties.\n    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n    if (!properties) return;\n    properties.delete(e.propertyName);\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n    }\n    // If no transitioning elements, call all of the queued callbacks.\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();\n      $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n    }\n  };\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') $bbed8b41f857bcc0$var$setupGlobalEvents();else document.addEventListener('DOMContentLoaded', $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n  });\n}\nexport { $bbed8b41f857bcc0$export$24490316f764c430 as runAfterTransition };","map":{"version":3,"sources":["packages/@react-aria/utils/src/runAfterTransition.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;AAUC,GAVD,CAYA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0CAAA,GAAuB,IAAI,GAAA,CAAA,CAAA;AAE/B;AACA,IAAI,yCAAA,GAAsB,IAAI,GAAA,CAAA,CAAA;AAE9B,SAAS,uCAAA,CAAA,EAAA;EACP,IAAI,OAAO,MAAA,KAAW,WAAA,EACpB;EAGF,SAAS,iBAAA,CAAkB,KAAY,EAAA;IACrC,OAAO,cAAA,IAAkB,KAAA;EAC3B;EAEA,IAAI,iBAAA,GAAqB,CAAA,IAAA;IACvB,IAAI,CAAC,iBAAA,CAAkB,CAAA,CAAA,IAAM,CAAC,CAAA,CAAE,MAAM,EACpC;IAEF;IACA,IAAI,WAAA,GAAc,0CAAA,CAAqB,GAAG,CAAC,CAAA,CAAE,MAAM,CAAA;IACnD,IAAI,CAAC,WAAA,EAAa;MAChB,WAAA,GAAc,IAAI,GAAA,CAAA,CAAA;MAClB,0CAAA,CAAqB,GAAG,CAAC,CAAA,CAAE,MAAM,EAAE,WAAA,CAAA;MAEnC;MACA;MACA;MACA,CAAA,CAAE,MAAM,CAAC,gBAAgB,CAAC,kBAAA,EAAoB,eAAA,EAAiB;QAC7D,IAAA,EAAM;MACR,CAAA,CAAA;IACF;IAEA,WAAA,CAAY,GAAG,CAAC,CAAA,CAAE,YAAY,CAAA;EAChC,CAAA;EAEA,IAAI,eAAA,GAAmB,CAAA,IAAA;IACrB,IAAI,CAAC,iBAAA,CAAkB,CAAA,CAAA,IAAM,CAAC,CAAA,CAAE,MAAM,EACpC;IAEF;IACA,IAAI,UAAA,GAAa,0CAAA,CAAqB,GAAG,CAAC,CAAA,CAAE,MAAM,CAAA;IAClD,IAAI,CAAC,UAAA,EACH;IAGF,UAAA,CAAW,MAAM,CAAC,CAAA,CAAE,YAAY,CAAA;IAEhC;IACA,IAAI,UAAA,CAAW,IAAI,KAAK,CAAA,EAAG;MACzB,CAAA,CAAE,MAAM,CAAC,mBAAmB,CAAC,kBAAA,EAAoB,eAAA,CAAA;MACjD,0CAAA,CAAqB,MAAM,CAAC,CAAA,CAAE,MAAM,CAAA;IACtC;IAEA;IACA,IAAI,0CAAA,CAAqB,IAAI,KAAK,CAAA,EAAG;MACnC,KAAK,IAAI,EAAA,IAAM,yCAAA,EACb,EAAA,CAAA,CAAA;MAGF,yCAAA,CAAoB,KAAK,CAAA,CAAA;IAC3B;EACF,CAAA;EAEA,QAAA,CAAS,IAAI,CAAC,gBAAgB,CAAC,eAAA,EAAiB,iBAAA,CAAA;EAChD,QAAA,CAAS,IAAI,CAAC,gBAAgB,CAAC,eAAA,EAAiB,eAAA,CAAA;AAClD;AAEA,IAAI,OAAO,QAAA,KAAa,WAAA,EAAA;EACtB,IAAI,QAAA,CAAS,UAAU,KAAK,SAAA,EAC1B,uCAAA,CAAA,CAAA,CAAA,KAEA,QAAA,CAAS,gBAAgB,CAAC,kBAAA,EAAoB,uCAAA,CAAA;;AAI3C,SAAS,yCAAA,CAAmB,EAAc,EAAA;EAC/C;EACA,qBAAA,CAAsB,MAAA;IACpB;IACA;IACA,IAAI,0CAAA,CAAqB,IAAI,KAAK,CAAA,EAChC,EAAA,CAAA,CAAA,CAAA,KAEA,yCAAA,CAAoB,GAAG,CAAC,EAAA,CAAA;EAE5B,CAAA,CAAA;AACF","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet transitionsByElement = new Map<EventTarget, Set<string>>();\n\n// A list of callbacks to call once there are no transitioning elements.\nlet transitionCallbacks = new Set<() => void>();\n\nfunction setupGlobalEvents() {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  function isTransitionEvent(event: Event): event is TransitionEvent {\n    return 'propertyName' in event;\n  }\n\n  let onTransitionStart = (e: Event) => {\n    if (!isTransitionEvent(e) || !e.target) {\n      return;\n    }\n    // Add the transitioning property to the list for this element.\n    let transitions = transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      transitionsByElement.set(e.target, transitions);\n\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener('transitioncancel', onTransitionEnd, {\n        once: true\n      });\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  let onTransitionEnd = (e: Event) => {\n    if (!isTransitionEvent(e) || !e.target) {\n      return;\n    }\n    // Remove property from list of transitioning properties.\n    let properties = transitionsByElement.get(e.target);\n    if (!properties) {\n      return;\n    }\n\n    properties.delete(e.propertyName);\n\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      transitionsByElement.delete(e.target);\n    }\n\n    // If no transitioning elements, call all of the queued callbacks.\n    if (transitionsByElement.size === 0) {\n      for (let cb of transitionCallbacks) {\n        cb();\n      }\n\n      transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalEvents);\n  }\n}\n\nexport function runAfterTransition(fn: () => void): void {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if (transitionsByElement.size === 0) {\n      fn();\n    } else {\n      transitionCallbacks.add(fn);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}
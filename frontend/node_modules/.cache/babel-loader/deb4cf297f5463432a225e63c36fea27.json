{"ast":null,"code":"import { useLayoutEffect as $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c } from \"./useLayoutEffect.module.js\";\nimport { flushSync as $jJMAe$flushSync } from \"react-dom\";\nimport { useState as $jJMAe$useState, useCallback as $jJMAe$useCallback } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $d3f049242431219c$export$6d3443f2c48bfc20(ref, isReady = true) {\n  let [isEntering, setEntering] = (0, $jJMAe$useState)(true);\n  let isAnimationReady = isEntering && isReady;\n  // There are two cases for entry animations:\n  // 1. CSS @keyframes. The `animation` property is set during the isEntering state, and it is removed after the animation finishes.\n  // 2. CSS transitions. The initial styles are applied during the isEntering state, and removed immediately, causing the transition to occur.\n  //\n  // In the second case, cancel any transitions that were triggered prior to the isEntering = false state (when the transition is supposed to start).\n  // This can happen when isReady starts as false (e.g. popovers prior to placement calculation).\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    if (isAnimationReady && ref.current && 'getAnimations' in ref.current) {\n      for (let animation of ref.current.getAnimations()) if (animation instanceof CSSTransition) animation.cancel();\n    }\n  }, [ref, isAnimationReady]);\n  $d3f049242431219c$var$useAnimation(ref, isAnimationReady, (0, $jJMAe$useCallback)(() => setEntering(false), []));\n  return isAnimationReady;\n}\nfunction $d3f049242431219c$export$45fda7c47f93fd48(ref, isOpen) {\n  let [exitState, setExitState] = (0, $jJMAe$useState)(isOpen ? 'open' : 'closed');\n  switch (exitState) {\n    case 'open':\n      // If isOpen becomes false, set the state to exiting.\n      if (!isOpen) setExitState('exiting');\n      break;\n    case 'closed':\n    case 'exiting':\n      // If we are exiting and isOpen becomes true, the animation was interrupted.\n      // Reset the state to open.\n      if (isOpen) setExitState('open');\n      break;\n  }\n  let isExiting = exitState === 'exiting';\n  $d3f049242431219c$var$useAnimation(ref, isExiting, (0, $jJMAe$useCallback)(() => {\n    // Set the state to closed, which will cause the element to be unmounted.\n    setExitState(state => state === 'exiting' ? 'closed' : state);\n  }, []));\n  return isExiting;\n}\nfunction $d3f049242431219c$var$useAnimation(ref, isActive, onEnd) {\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    if (isActive && ref.current) {\n      if (!('getAnimations' in ref.current)) {\n        // JSDOM\n        onEnd();\n        return;\n      }\n      let animations = ref.current.getAnimations();\n      if (animations.length === 0) {\n        onEnd();\n        return;\n      }\n      let canceled = false;\n      Promise.all(animations.map(a => a.finished)).then(() => {\n        if (!canceled) (0, $jJMAe$flushSync)(() => {\n          onEnd();\n        });\n      }).catch(() => {});\n      return () => {\n        canceled = true;\n      };\n    }\n  }, [ref, isActive, onEnd]);\n}\nexport { $d3f049242431219c$export$6d3443f2c48bfc20 as useEnterAnimation, $d3f049242431219c$export$45fda7c47f93fd48 as useExitAnimation };","map":{"version":3,"sources":["packages/@react-aria/utils/src/animation.ts"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;AAUC;;AAMM,SAAS,yCAAA,CAAkB,GAAkC,EAAE,OAAA,GAAmB,IAAI,EAAA;EAC3F,IAAI,CAAC,UAAA,EAAY,WAAA,CAAY,GAAG,CAAA,CAAA,EAAA,eAAO,EAAE,IAAA,CAAA;EACzC,IAAI,gBAAA,GAAmB,UAAA,IAAc,OAAA;EAErC;EACA;EACA;EACA;EACA;EACA;EACA,CAAA,CAAA,EAAA,yCAAc,EAAE,MAAA;IACd,IAAI,gBAAA,IAAoB,GAAA,CAAI,OAAO,IAAI,eAAA,IAAmB,GAAA,CAAI,OAAO,EAAE;MACrE,KAAK,IAAI,SAAA,IAAa,GAAA,CAAI,OAAO,CAAC,aAAa,CAAA,CAAA,EAC7C,IAAI,SAAA,YAAqB,aAAA,EACvB,SAAA,CAAU,MAAM,CAAA,CAAA;IAGtB;EACF,CAAA,EAAG,CAAC,GAAA,EAAK,gBAAA,CAAiB,CAAA;EAE1B,kCAAA,CAAa,GAAA,EAAK,gBAAA,EAAkB,CAAA,CAAA,EAAA,kBAAU,EAAE,MAAM,WAAA,CAAY,KAAA,CAAA,EAAQ,EAAE,CAAA,CAAA;EAC5E,OAAO,gBAAA;AACT;AAEO,SAAS,yCAAA,CAAiB,GAAkC,EAAE,MAAe,EAAA;EAClF,IAAI,CAAC,SAAA,EAAW,YAAA,CAAa,GAAG,CAAA,CAAA,EAAA,eAAO,EAAiC,MAAA,GAAS,MAAA,GAAS,QAAA,CAAA;EAE1F,QAAQ,SAAA;IACN,KAAK,MAAA;MACH;MACA,IAAI,CAAC,MAAA,EACH,YAAA,CAAa,SAAA,CAAA;MAEf;IACF,KAAK,QAAA;IACL,KAAK,SAAA;MACH;MACA;MACA,IAAI,MAAA,EACF,YAAA,CAAa,MAAA,CAAA;MAEf;EACJ;EAEA,IAAI,SAAA,GAAY,SAAA,KAAc,SAAA;EAC9B,kCAAA,CACE,GAAA,EACA,SAAA,EACA,CAAA,CAAA,EAAA,kBAAU,EAAE,MAAA;IACV;IACA,YAAA,CAAa,KAAA,IAAS,KAAA,KAAU,SAAA,GAAY,QAAA,GAAW,KAAA,CAAA;EACzD,CAAA,EAAG,EAAE,CAAA,CAAA;EAGP,OAAO,SAAA;AACT;AAEA,SAAS,kCAAA,CAAa,GAAkC,EAAE,QAAiB,EAAE,KAAiB,EAAA;EAC5F,CAAA,CAAA,EAAA,yCAAc,EAAE,MAAA;IACd,IAAI,QAAA,IAAY,GAAA,CAAI,OAAO,EAAE;MAC3B,IAAI,EAAE,eAAA,IAAmB,GAAA,CAAI,OAAO,CAAA,EAAG;QACrC;QACA,KAAA,CAAA,CAAA;QACA;MACF;MAEA,IAAI,UAAA,GAAa,GAAA,CAAI,OAAO,CAAC,aAAa,CAAA,CAAA;MAC1C,IAAI,UAAA,CAAW,MAAM,KAAK,CAAA,EAAG;QAC3B,KAAA,CAAA,CAAA;QACA;MACF;MAEA,IAAI,QAAA,GAAW,KAAA;MACf,OAAA,CAAQ,GAAG,CAAC,UAAA,CAAW,GAAG,CAAC,CAAA,IAAK,CAAA,CAAE,QAAQ,CAAA,CAAA,CAAG,IAAI,CAAC,MAAA;QAChD,IAAI,CAAC,QAAA,EACH,CAAA,CAAA,EAAA,gBAAQ,EAAE,MAAA;UACR,KAAA,CAAA,CAAA;QACF,CAAA,CAAA;MAEJ,CAAA,CAAA,CAAG,KAAK,CAAC,MAAA,CAAO,CAAA,CAAA;MAEhB,OAAO,MAAA;QACL,QAAA,GAAW,IAAA;MACb,CAAA;IACF;EACF,CAAA,EAAG,CAAC,GAAA,EAAK,QAAA,EAAU,KAAA,CAAM,CAAA;AAC3B","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {flushSync} from 'react-dom';\nimport {RefObject, useCallback, useState} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\n\nexport function useEnterAnimation(ref: RefObject<HTMLElement | null>, isReady: boolean = true): boolean {\n  let [isEntering, setEntering] = useState(true);\n  let isAnimationReady = isEntering && isReady;\n\n  // There are two cases for entry animations:\n  // 1. CSS @keyframes. The `animation` property is set during the isEntering state, and it is removed after the animation finishes.\n  // 2. CSS transitions. The initial styles are applied during the isEntering state, and removed immediately, causing the transition to occur.\n  //\n  // In the second case, cancel any transitions that were triggered prior to the isEntering = false state (when the transition is supposed to start).\n  // This can happen when isReady starts as false (e.g. popovers prior to placement calculation).\n  useLayoutEffect(() => {\n    if (isAnimationReady && ref.current && 'getAnimations' in ref.current) {\n      for (let animation of ref.current.getAnimations()) {\n        if (animation instanceof CSSTransition) {\n          animation.cancel();\n        }\n      }\n    }\n  }, [ref, isAnimationReady]);\n\n  useAnimation(ref, isAnimationReady, useCallback(() => setEntering(false), []));\n  return isAnimationReady;\n}\n\nexport function useExitAnimation(ref: RefObject<HTMLElement | null>, isOpen: boolean): boolean {\n  let [exitState, setExitState] = useState<'closed' | 'open' | 'exiting'>(isOpen ? 'open' : 'closed');\n\n  switch (exitState) {\n    case 'open':\n      // If isOpen becomes false, set the state to exiting.\n      if (!isOpen) {\n        setExitState('exiting');\n      }\n      break;\n    case 'closed':\n    case 'exiting':\n      // If we are exiting and isOpen becomes true, the animation was interrupted.\n      // Reset the state to open.\n      if (isOpen) {\n        setExitState('open');\n      }\n      break;\n  }\n\n  let isExiting = exitState === 'exiting';\n  useAnimation(\n    ref,\n    isExiting,\n    useCallback(() => {\n      // Set the state to closed, which will cause the element to be unmounted.\n      setExitState(state => state === 'exiting' ? 'closed' : state);\n    }, [])\n  );\n\n  return isExiting;\n}\n\nfunction useAnimation(ref: RefObject<HTMLElement | null>, isActive: boolean, onEnd: () => void): void {\n  useLayoutEffect(() => {\n    if (isActive && ref.current) {\n      if (!('getAnimations' in ref.current)) {\n        // JSDOM\n        onEnd();\n        return;\n      }\n\n      let animations = ref.current.getAnimations();\n      if (animations.length === 0) {\n        onEnd();\n        return;\n      }\n\n      let canceled = false;\n      Promise.all(animations.map(a => a.finished)).then(() => {\n        if (!canceled) {\n          flushSync(() => {\n            onEnd();\n          });\n        }\n      }).catch(() => {});\n\n      return () => {\n        canceled = true;\n      };\n    }\n  }, [ref, isActive, onEnd]);\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /**\n    * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n    */function $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\nfunction $9446cca9a3875146$export$e1a7b8e69ef6c52f(value, step) {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf('.');\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n  min = Number(min);\n  max = Number(max);\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);\n  if (!isNaN(min)) {\n    if (snappedValue < min) snappedValue = min;else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f((max - min) / step, step)) * step;\n  } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f(max / step, step)) * step;\n  // correct floating point behavior by rounding to step precision\n  snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(snappedValue, step);\n  return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\nexport { $9446cca9a3875146$export$7d15b64cf5a3a4c4 as clamp, $9446cca9a3875146$export$e1a7b8e69ef6c52f as roundToStepPrecision, $9446cca9a3875146$export$cb6e0bb50bc19463 as snapValueToStep, $9446cca9a3875146$export$b6268554fba451f as toFixedNumber };","map":{"version":3,"sources":["packages/@react-stately/utils/src/number.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;AAUC,GAVD,CAYA;;AAEC,MACM,SAAS,yCAAA,CAAM,KAAa,EAAE,GAAA,GAAc,CAAC,QAAQ,EAAE,GAAA,GAAc,QAAQ,EAAA;EAClF,IAAI,QAAA,GAAW,IAAA,CAAK,GAAG,CAAC,IAAA,CAAK,GAAG,CAAC,KAAA,EAAO,GAAA,CAAA,EAAM,GAAA,CAAA;EAC9C,OAAO,QAAA;AACT;AAEO,SAAS,yCAAA,CAAqB,KAAa,EAAE,IAAY,EAAA;EAC9D,IAAI,YAAA,GAAe,KAAA;EACnB,IAAI,UAAA,GAAa,IAAA,CAAK,QAAQ,CAAA,CAAA;EAC9B,IAAI,UAAA,GAAa,UAAA,CAAW,OAAO,CAAC,GAAA,CAAA;EACpC,IAAI,SAAA,GAAY,UAAA,IAAc,CAAA,GAAI,UAAA,CAAW,MAAM,GAAG,UAAA,GAAa,CAAA;EACnE,IAAI,SAAA,GAAY,CAAA,EAAG;IACjB,IAAI,GAAA,GAAM,IAAA,CAAK,GAAG,CAAC,EAAA,EAAI,SAAA,CAAA;IACvB,YAAA,GAAe,IAAA,CAAK,KAAK,CAAC,YAAA,GAAe,GAAA,CAAA,GAAO,GAAA;EAClD;EACA,OAAO,YAAA;AACT;AAEO,SAAS,yCAAA,CAAgB,KAAa,EAAE,GAAuB,EAAE,GAAuB,EAAE,IAAY,EAAA;EAC3G,GAAA,GAAM,MAAA,CAAO,GAAA,CAAA;EACb,GAAA,GAAM,MAAA,CAAO,GAAA,CAAA;EACb,IAAI,SAAA,GAAc,CAAA,KAAA,IAAS,KAAA,CAAM,GAAA,CAAA,GAAO,CAAA,GAAI,GAAE,CAAC,IAAK,IAAA;EACpD,IAAI,YAAA,GAAe,yCAAA,CAAqB,IAAA,CAAK,GAAG,CAAC,SAAA,CAAA,GAAa,CAAA,IAAK,IAAA,GAC/D,KAAA,GAAQ,IAAA,CAAK,IAAI,CAAC,SAAA,CAAA,IAAc,IAAA,GAAO,IAAA,CAAK,GAAG,CAAC,SAAA,CAAS,CAAA,GACzD,KAAA,GAAQ,SAAA,EAAW,IAAA,CAAA;EAEvB,IAAI,CAAC,KAAA,CAAM,GAAA,CAAA,EAAM;IACf,IAAI,YAAA,GAAe,GAAA,EACjB,YAAA,GAAe,GAAA,CAAA,KACV,IAAI,CAAC,KAAA,CAAM,GAAA,CAAA,IAAQ,YAAA,GAAe,GAAA,EACvC,YAAA,GAAe,GAAA,GAAM,IAAA,CAAK,KAAK,CAAC,yCAAA,CAAsB,CAAA,GAAA,GAAM,GAAE,IAAK,IAAA,EAAM,IAAA,CAAA,CAAA,GAAS,IAAA;EAEtF,CAAA,MAAO,IAAI,CAAC,KAAA,CAAM,GAAA,CAAA,IAAQ,YAAA,GAAe,GAAA,EACvC,YAAA,GAAe,IAAA,CAAK,KAAK,CAAC,yCAAA,CAAqB,GAAA,GAAM,IAAA,EAAM,IAAA,CAAA,CAAA,GAAS,IAAA;EAGtE;EACA,YAAA,GAAe,yCAAA,CAAqB,YAAA,EAAc,IAAA,CAAA;EAElD,OAAO,YAAA;AACT;AAGO,SAAS,wCAAA,CAAc,KAAa,EAAE,MAAc,EAAE,IAAA,GAAe,EAAE,EAAA;EAC5E,MAAM,GAAA,GAAM,IAAA,CAAK,GAAG,CAAC,IAAA,EAAM,MAAA,CAAA;EAE3B,OAAO,IAAA,CAAK,KAAK,CAAC,KAAA,GAAQ,GAAA,CAAA,GAAO,GAAA;AACnC","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function roundToStepPrecision(value: number, step: number): number {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf('.');\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\n\nexport function snapValueToStep(value: number, min: number | undefined, max: number | undefined, step: number): number {\n  min = Number(min);\n  max = Number(max);\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder, step);\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  snappedValue = roundToStepPrecision(snappedValue, step);\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"module"}
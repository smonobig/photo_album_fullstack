{"ast":null,"code":"import { useLayoutEffect as $6dfIe$useLayoutEffect, useEffectEvent as $6dfIe$useEffectEvent, isFocusable as $6dfIe$isFocusable, getOwnerWindow as $6dfIe$getOwnerWindow, focusWithoutScrolling as $6dfIe$focusWithoutScrolling } from \"@react-aria/utils\";\nimport { useRef as $6dfIe$useRef, useCallback as $6dfIe$useCallback } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {\n  let event = nativeEvent;\n  event.nativeEvent = nativeEvent;\n  event.isDefaultPrevented = () => event.defaultPrevented;\n  // cancelBubble is technically deprecated in the spec, but still supported in all browsers.\n  event.isPropagationStopped = () => event.cancelBubble;\n  event.persist = () => {};\n  return event;\n}\nfunction $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {\n  Object.defineProperty(event, 'target', {\n    value: target\n  });\n  Object.defineProperty(event, 'currentTarget', {\n    value: target\n  });\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n  let stateRef = (0, $6dfIe$useRef)({\n    isFocused: false,\n    observer: null\n  });\n  // Clean up MutationObserver on unmount. See below.\n  (0, $6dfIe$useLayoutEffect)(() => {\n    const state = stateRef.current;\n    return () => {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n  let dispatchBlur = (0, $6dfIe$useEffectEvent)(e => {\n    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n  });\n  // This function is called during a React onFocus event.\n  return (0, $6dfIe$useCallback)(e => {\n    // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n    // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n    // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n    // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n    if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n      stateRef.current.isFocused = true;\n      let target = e.target;\n      let onBlurHandler = e => {\n        stateRef.current.isFocused = false;\n        if (target.disabled) {\n          // For backward compatibility, dispatch a (fake) React synthetic event.\n          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e);\n          dispatchBlur(event);\n        }\n        // We no longer need the MutationObserver once the target is blurred.\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n      target.addEventListener('focusout', onBlurHandler, {\n        once: true\n      });\n      stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          var _stateRef_current_observer;\n          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent('blur', {\n            relatedTarget: relatedTargetEl\n          }));\n          target.dispatchEvent(new FocusEvent('focusout', {\n            bubbles: true,\n            relatedTarget: relatedTargetEl\n          }));\n        }\n      });\n      stateRef.current.observer.observe(target, {\n        attributes: true,\n        attributeFilter: ['disabled']\n      });\n    }\n  }, [dispatchBlur]);\n}\nlet $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;\nfunction $8a9cb279dc87e130$export$cabe61c495ee3649(target) {\n  // The browser will focus the nearest focusable ancestor of our target.\n  while (target && !(0, $6dfIe$isFocusable)(target)) target = target.parentElement;\n  let window = (0, $6dfIe$getOwnerWindow)(target);\n  let activeElement = window.document.activeElement;\n  if (!activeElement || activeElement === target) return;\n  $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;\n  let isRefocusing = false;\n  let onBlur = e => {\n    if (e.target === activeElement || isRefocusing) e.stopImmediatePropagation();\n  };\n  let onFocusOut = e => {\n    if (e.target === activeElement || isRefocusing) {\n      e.stopImmediatePropagation();\n      // If there was no focusable ancestor, we don't expect a focus event.\n      // Re-focus the original active element here.\n      if (!target && !isRefocusing) {\n        isRefocusing = true;\n        (0, $6dfIe$focusWithoutScrolling)(activeElement);\n        cleanup();\n      }\n    }\n  };\n  let onFocus = e => {\n    if (e.target === target || isRefocusing) e.stopImmediatePropagation();\n  };\n  let onFocusIn = e => {\n    if (e.target === target || isRefocusing) {\n      e.stopImmediatePropagation();\n      if (!isRefocusing) {\n        isRefocusing = true;\n        (0, $6dfIe$focusWithoutScrolling)(activeElement);\n        cleanup();\n      }\n    }\n  };\n  window.addEventListener('blur', onBlur, true);\n  window.addEventListener('focusout', onFocusOut, true);\n  window.addEventListener('focusin', onFocusIn, true);\n  window.addEventListener('focus', onFocus, true);\n  let cleanup = () => {\n    cancelAnimationFrame(raf);\n    window.removeEventListener('blur', onBlur, true);\n    window.removeEventListener('focusout', onFocusOut, true);\n    window.removeEventListener('focusin', onFocusIn, true);\n    window.removeEventListener('focus', onFocus, true);\n    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;\n    isRefocusing = false;\n  };\n  let raf = requestAnimationFrame(cleanup);\n  return cleanup;\n}\nexport { $8a9cb279dc87e130$export$525bc4921d56d4a as createSyntheticEvent, $8a9cb279dc87e130$export$c2b7abe5d61ec696 as setEventTarget, $8a9cb279dc87e130$export$715c682d09d639cc as useSyntheticBlurEvent, $8a9cb279dc87e130$export$fda7da73ab5d4c48 as ignoreFocusEvent, $8a9cb279dc87e130$export$cabe61c495ee3649 as preventFocus };","map":{"version":3,"sources":["packages/@react-aria/interactions/src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerWindow, isFocusable, useEffectEvent, useLayoutEffect} from '@react-aria/utils';\nimport {FocusEvent as ReactFocusEvent, SyntheticEvent, useCallback, useRef} from 'react';\n\n// Turn a native event into a React synthetic event.\nexport function createSyntheticEvent<E extends SyntheticEvent>(nativeEvent: Event): E {\n  let event = nativeEvent as any as E;\n  event.nativeEvent = nativeEvent;\n  event.isDefaultPrevented = () => event.defaultPrevented;\n  // cancelBubble is technically deprecated in the spec, but still supported in all browsers.\n  event.isPropagationStopped = () => (event as any).cancelBubble;\n  event.persist = () => {};\n  return event;\n}\n\nexport function setEventTarget(event: Event, target: Element): void {\n  Object.defineProperty(event, 'target', {value: target});\n  Object.defineProperty(event, 'currentTarget', {value: target});\n}\n\nexport function useSyntheticBlurEvent<Target extends Element = Element>(onBlur: (e: ReactFocusEvent<Target>) => void): (e: ReactFocusEvent<Target>) => void {\n  let stateRef = useRef({\n    isFocused: false,\n    observer: null as MutationObserver | null\n  });\n\n  // Clean up MutationObserver on unmount. See below.\n\n  useLayoutEffect(() => {\n    const state = stateRef.current;\n    return () => {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n\n  let dispatchBlur = useEffectEvent((e: ReactFocusEvent<Target>) => {\n    onBlur?.(e);\n  });\n\n  // This function is called during a React onFocus event.\n  return useCallback((e: ReactFocusEvent<Target>) => {\n    // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n    // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n    // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n    // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n    if (\n      e.target instanceof HTMLButtonElement ||\n      e.target instanceof HTMLInputElement ||\n      e.target instanceof HTMLTextAreaElement ||\n      e.target instanceof HTMLSelectElement\n    ) {\n      stateRef.current.isFocused = true;\n\n      let target = e.target;\n      let onBlurHandler: EventListenerOrEventListenerObject | null = (e) => {\n        stateRef.current.isFocused = false;\n\n        if (target.disabled) {\n          // For backward compatibility, dispatch a (fake) React synthetic event.\n          let event = createSyntheticEvent<ReactFocusEvent<Target>>(e);\n          dispatchBlur(event);\n        }\n\n        // We no longer need the MutationObserver once the target is blurred.\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n\n      target.addEventListener('focusout', onBlurHandler, {once: true});\n\n      stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          stateRef.current.observer?.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent('blur', {relatedTarget: relatedTargetEl}));\n          target.dispatchEvent(new FocusEvent('focusout', {bubbles: true, relatedTarget: relatedTargetEl}));\n        }\n      });\n\n      stateRef.current.observer.observe(target, {attributes: true, attributeFilter: ['disabled']});\n    }\n  }, [dispatchBlur]);\n}\n\nexport let ignoreFocusEvent = false;\n\n/**\n * This function prevents the next focus event fired on `target`, without using `event.preventDefault()`.\n * It works by waiting for the series of focus events to occur, and reverts focus back to where it was before.\n * It also makes these events mostly non-observable by using a capturing listener on the window and stopping propagation.\n */\nexport function preventFocus(target: FocusableElement | null): (() => void) | undefined {\n  // The browser will focus the nearest focusable ancestor of our target.\n  while (target && !isFocusable(target)) {\n    target = target.parentElement;\n  }\n\n  let window = getOwnerWindow(target);\n  let activeElement = window.document.activeElement as FocusableElement | null;\n  if (!activeElement || activeElement === target) {\n    return;\n  }\n\n  ignoreFocusEvent = true;\n  let isRefocusing = false;\n  let onBlur = (e: FocusEvent) => {\n    if (e.target === activeElement || isRefocusing) {\n      e.stopImmediatePropagation();\n    }\n  };\n\n  let onFocusOut = (e: FocusEvent) => {\n    if (e.target === activeElement || isRefocusing) {\n      e.stopImmediatePropagation();\n\n      // If there was no focusable ancestor, we don't expect a focus event.\n      // Re-focus the original active element here.\n      if (!target && !isRefocusing) {\n        isRefocusing = true;\n        focusWithoutScrolling(activeElement);\n        cleanup();\n      }\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    if (e.target === target || isRefocusing) {\n      e.stopImmediatePropagation();\n    }\n  };\n\n  let onFocusIn = (e: FocusEvent) => {\n    if (e.target === target || isRefocusing) {\n      e.stopImmediatePropagation();\n\n      if (!isRefocusing) {\n        isRefocusing = true;\n        focusWithoutScrolling(activeElement);\n        cleanup();\n      }\n    }\n  };\n\n  window.addEventListener('blur', onBlur, true);\n  window.addEventListener('focusout', onFocusOut, true);\n  window.addEventListener('focusin', onFocusIn, true);\n  window.addEventListener('focus', onFocus, true);\n\n  let cleanup = () => {\n    cancelAnimationFrame(raf);\n    window.removeEventListener('blur', onBlur, true);\n    window.removeEventListener('focusout', onFocusOut, true);\n    window.removeEventListener('focusin', onFocusIn, true);\n    window.removeEventListener('focus', onFocus, true);\n    ignoreFocusEvent = false;\n    isRefocusing = false;\n  };\n\n  let raf = requestAnimationFrame(cleanup);\n  return cleanup;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { createSyntheticEvent as $8a9cb279dc87e130$export$525bc4921d56d4a, preventFocus as $8a9cb279dc87e130$export$cabe61c495ee3649, setEventTarget as $8a9cb279dc87e130$export$c2b7abe5d61ec696 } from \"./utils.module.js\";\nimport { disableTextSelection as $14c0b72509d70225$export$16a4697467175487, restoreTextSelection as $14c0b72509d70225$export$b0d6fa1ab32e3295 } from \"./textSelection.module.js\";\nimport { PressResponderContext as $ae1eeba8b9eafd08$export$5165eccb35aaadb5 } from \"./context.module.js\";\nimport { _ as $7mdmh$_ } from \"@swc/helpers/_/_class_private_field_get\";\nimport { _ as $7mdmh$_1 } from \"@swc/helpers/_/_class_private_field_init\";\nimport { _ as $7mdmh$_2 } from \"@swc/helpers/_/_class_private_field_set\";\nimport { mergeProps as $7mdmh$mergeProps, useSyncRef as $7mdmh$useSyncRef, useGlobalListeners as $7mdmh$useGlobalListeners, useEffectEvent as $7mdmh$useEffectEvent, nodeContains as $7mdmh$nodeContains, getEventTarget as $7mdmh$getEventTarget, getOwnerDocument as $7mdmh$getOwnerDocument, chain as $7mdmh$chain, isMac as $7mdmh$isMac, openLink as $7mdmh$openLink, isVirtualClick as $7mdmh$isVirtualClick, isVirtualPointerEvent as $7mdmh$isVirtualPointerEvent, focusWithoutScrolling as $7mdmh$focusWithoutScrolling, getOwnerWindow as $7mdmh$getOwnerWindow } from \"@react-aria/utils\";\nimport { flushSync as $7mdmh$flushSync } from \"react-dom\";\nimport { useContext as $7mdmh$useContext, useState as $7mdmh$useState, useRef as $7mdmh$useRef, useMemo as $7mdmh$useMemo, useEffect as $7mdmh$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n  // Consume context from <PressResponder> and merge with props.\n  let context = (0, $7mdmh$useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n  if (context) {\n    let {\n      register: register,\n      ...contextProps\n    } = context;\n    props = (0, $7mdmh$mergeProps)(contextProps, props);\n    register();\n  }\n  (0, $7mdmh$useSyncRef)(context, props.ref);\n  return props;\n}\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/new WeakMap();\nclass $f6c31cce2adf654f$var$PressEvent {\n  continuePropagation() {\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n  }\n  get shouldStopPropagation() {\n    return (0, $7mdmh$_)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n  }\n  constructor(type, pointerType, originalEvent, state) {\n    (0, $7mdmh$_1)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n      writable: true,\n      value: void 0\n    });\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n    var _state_target;\n    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;\n    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();\n    let x,\n      y = 0;\n    let clientX,\n      clientY = null;\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n}\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol('linkClicked');\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n  let {\n    onPress: onPress,\n    onPressChange: onPressChange,\n    onPressStart: onPressStart,\n    onPressEnd: onPressEnd,\n    onPressUp: onPressUp,\n    onClick: onClick,\n    isDisabled: isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress: preventFocusOnPress,\n    shouldCancelOnPointerExit: shouldCancelOnPointerExit,\n    allowTextSelectionOnPress: allowTextSelectionOnPress,\n    ref: domRef,\n    ...domProps\n  } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n  let [isPressed, setPressed] = (0, $7mdmh$useState)(false);\n  let ref = (0, $7mdmh$useRef)({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $7mdmh$useGlobalListeners)();\n  let triggerPressStart = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) return false;\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(true);\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) return false;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(false);\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  let triggerPressUp = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) return false;\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  let cancel = (0, $7mdmh$useEffectEvent)(e => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n      for (let dispose of state.disposables) dispose();\n      state.disposables = [];\n    }\n  });\n  let cancelOnPointerExit = (0, $7mdmh$useEffectEvent)(e => {\n    if (shouldCancelOnPointerExit) cancel(e);\n  });\n  let triggerClick = (0, $7mdmh$useEffectEvent)(e => {\n    onClick === null || onClick === void 0 ? void 0 : onClick(e);\n  });\n  let triggerSyntheticClick = (0, $7mdmh$useEffectEvent)((e, target) => {\n    // Some third-party libraries pass in onClick instead of onPress.\n    // Create a fake mouse event and trigger onClick as well.\n    // This matches the browser's native activation behavior for certain elements (e.g. button).\n    // https://html.spec.whatwg.org/#activation\n    // https://html.spec.whatwg.org/#fire-a-synthetic-pointer-event\n    if (onClick) {\n      let event = new MouseEvent('click', e);\n      (0, $8a9cb279dc87e130$export$c2b7abe5d61ec696)(event, target);\n      onClick((0, $8a9cb279dc87e130$export$525bc4921d56d4a)(event));\n    }\n  });\n  let pressProps = (0, $7mdmh$useMemo)(() => {\n    let state = ref.current;\n    let pressProps = {\n      onKeyDown(e) {\n        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && (0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) {\n          var _state_metaKeyEvents;\n          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $7mdmh$getEventTarget)(e.nativeEvent), e.key)) e.preventDefault();\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = e => {\n              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e, originalTarget) && !e.repeat && (0, $7mdmh$nodeContains)(originalTarget, (0, $7mdmh$getEventTarget)(e)) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard');\n            };\n            addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'keyup', (0, $7mdmh$chain)(pressUp, onKeyUp), true);\n          }\n          if (shouldStopPropagation) e.stopPropagation();\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && (0, $7mdmh$isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n        } else if (e.key === 'Meta') state.metaKeyEvents = new Map();\n      },\n      onClick(e) {\n        if (e && !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $7mdmh$openLink).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) e.preventDefault();\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || (0, $7mdmh$isVirtualClick)(e.nativeEvent))) {\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            let pointerType = state.pointerType || e.nativeEvent.pointerType || 'virtual';\n            shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createEvent(e.currentTarget, e), pointerType, true);\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) e.stopPropagation();\n        }\n      }\n    };\n    let onKeyUp = e => {\n      var _state_metaKeyEvents;\n      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n        var _state_metaKeyEvents1;\n        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $7mdmh$getEventTarget)(e), e.key)) e.preventDefault();\n        let target = (0, $7mdmh$getEventTarget)(e);\n        let wasPressed = (0, $7mdmh$nodeContains)(state.target, (0, $7mdmh$getEventTarget)(e));\n        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) triggerSyntheticClick(e, state.target);\n        removeAllGlobalListeners();\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && (0, $7mdmh$nodeContains)(state.target, target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n          (0, $7mdmh$openLink)(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n      } else if (e.key === 'Meta' && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n        var _state_target;\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent('keyup', event));\n      }\n    };\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = e => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if ((0, $7mdmh$isVirtualPointerEvent)(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          // Release pointer capture so that touch interactions can leave the original target.\n          // This enables onPointerLeave and onPointerEnter to fire.\n          let target = (0, $7mdmh$getEventTarget)(e.nativeEvent);\n          if ('releasePointerCapture' in target) target.releasePointerCapture(e.pointerId);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseDown = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e.target);\n            if (dispose) state.disposables.push(dispose);\n          }\n          e.stopPropagation();\n        }\n      };\n      pressProps.onPointerUp = e => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent)) || state.pointerType === 'virtual') return;\n        // Only handle left clicks\n        if (e.button === 0) triggerPressUp(e, state.pointerType || e.pointerType);\n      };\n      pressProps.onPointerEnter = e => {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n        }\n      };\n      pressProps.onPointerLeave = e => {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      let onPointerUp = e => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if ((0, $7mdmh$nodeContains)(state.target, (0, $7mdmh$getEventTarget)(e)) && state.pointerType != null) {\n            // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n            // is mutated between onPointerUp and onClick, and is more compatible with third party libraries.\n            // https://github.com/adobe/react-spectrum/issues/1513\n            // https://issues.chromium.org/issues/40732224\n            // However, iOS and Android do not focus or fire onClick after a long press.\n            // We work around this by triggering a click ourselves after a timeout.\n            // This timeout is canceled during the click event in case the real one fires first.\n            // The timeout must be at least 32ms, because Safari on iOS delays the click event on\n            // non-form elements without certain ARIA roles (for hover emulation).\n            // https://github.com/WebKit/WebKit/blob/dccfae42bb29bd4bdef052e469f604a9387241c0/Source/WebKit/WebProcess/WebPage/ios/WebPageIOS.mm#L875-L892\n            let clicked = false;\n            let timeout = setTimeout(() => {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) cancel(e);else {\n                  (0, $7mdmh$focusWithoutScrolling)(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80);\n            // Use a capturing listener to track if a click occurred.\n            // If stopPropagation is called it may never reach our handler.\n            addGlobalListener(e.currentTarget, 'click', () => clicked = true, true);\n            state.disposables.push(() => clearTimeout(timeout));\n          } else cancel(e);\n          // Ignore subsequent onPointerLeave event before onClick on touch devices.\n          state.isOverTarget = false;\n        }\n      };\n      let onPointerCancel = e => {\n        cancel(e);\n      };\n      pressProps.onDragStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      // NOTE: this fallback branch is entirely used by unit tests.\n      // All browsers now support pointer events, but JSDOM still does not.\n      pressProps.onMouseDown = e => {\n        // Only handle left clicks\n        if (e.button !== 0 || !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = (0, $7mdmh$isVirtualClick)(e.nativeEvent) ? 'virtual' : 'mouse';\n        // Flush sync so that focus moved during react re-renders occurs before we yield back to the browser.\n        let shouldStopPropagation = (0, $7mdmh$flushSync)(() => triggerPressStart(e, state.pointerType));\n        if (shouldStopPropagation) e.stopPropagation();\n        if (preventFocusOnPress) {\n          let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e.target);\n          if (dispose) state.disposables.push(dispose);\n        }\n        addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n      pressProps.onMouseEnter = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseLeave = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseUp = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || 'mouse');\n      };\n      let onMouseUp = e => {\n        // Only handle left clicks\n        if (e.button !== 0) return;\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if (state.target && state.target.contains(e.target) && state.pointerType != null) ;else cancel(e);\n        state.isOverTarget = false;\n      };\n      pressProps.onTouchStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n        if (!touch) return;\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n        if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n        let shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener((0, $7mdmh$getOwnerWindow)(e.currentTarget), 'scroll', onScroll, true);\n      };\n      pressProps.onTouchMove = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit($f6c31cce2adf654f$var$createTouchEvent(state.target, e));\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onTouchEnd = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target);\n        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType, false);\n        if (shouldStopPropagation) e.stopPropagation();\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        removeAllGlobalListeners();\n      };\n      pressProps.onTouchCancel = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        e.stopPropagation();\n        if (state.isPressed) cancel($f6c31cce2adf654f$var$createTouchEvent(state.target, e));\n      };\n      let onScroll = e => {\n        if (state.isPressed && (0, $7mdmh$nodeContains)((0, $7mdmh$getEventTarget)(e), state.target)) cancel({\n          currentTarget: state.target,\n          shiftKey: false,\n          ctrlKey: false,\n          metaKey: false,\n          altKey: false\n        });\n      };\n      pressProps.onDragStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        cancel(e);\n      };\n    }\n    return pressProps;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp, triggerClick, triggerSyntheticClick]);\n  // Avoid onClick delay for double tap to zoom by default.\n  (0, $7mdmh$useEffect)(() => {\n    let element = domRef === null || domRef === void 0 ? void 0 : domRef.current;\n    if (element && element instanceof (0, $7mdmh$getOwnerWindow)(element).Element) {\n      // Only apply touch-action if not already set by another CSS rule.\n      let style = (0, $7mdmh$getOwnerWindow)(element).getComputedStyle(element);\n      if (style.touchAction === 'auto')\n        // touchAction: 'manipulation' is supposed to be equivalent, but in \n        // Safari it causes onPointerCancel not to fire on scroll.\n        // https://bugs.webkit.org/show_bug.cgi?id=240917\n        element.style.touchAction = 'pan-x pan-y pinch-zoom';\n    }\n  }, [domRef]);\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  (0, $7mdmh$useEffect)(() => {\n    let state = ref.current;\n    return () => {\n      var _state_target;\n      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : undefined);\n      for (let dispose of state.disposables) dispose();\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: (0, $7mdmh$mergeProps)(domProps, pressProps)\n  };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n  const {\n    key: key,\n    code: code\n  } = event;\n  const element = currentTarget;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) &&\n  // Links should only trigger with Enter key\n  !((role === 'link' || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== 'Enter');\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n  const {\n    targetTouches: targetTouches\n  } = event;\n  if (targetTouches.length > 0) return targetTouches[0];\n  return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) return touch;\n  }\n  return null;\n}\nfunction $f6c31cce2adf654f$var$createTouchEvent(target, e) {\n  let clientX = 0;\n  let clientY = 0;\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n  let clientX = e.clientX;\n  let clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) offsetX = point.width / 2;else if (point.radiusX !== undefined) offsetX = point.radiusX;\n  if (point.height !== undefined) offsetY = point.height / 2;else if (point.radiusY !== undefined) offsetY = point.radiusY;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) return false;\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) return false;\n  return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {\n  if (target instanceof HTMLInputElement) return false;\n  if (target instanceof HTMLButtonElement) return target.type !== 'submit' && target.type !== 'reset';\n  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n  return true;\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\nexport { $f6c31cce2adf654f$export$45712eceda6fad21 as usePress };","map":{"version":3,"sources":["packages/@react-aria/interactions/src/usePress.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {\n  chain,\n  focusWithoutScrolling,\n  getEventTarget,\n  getOwnerDocument,\n  getOwnerWindow,\n  isMac,\n  isVirtualClick,\n  isVirtualPointerEvent,\n  mergeProps,\n  nodeContains,\n  openLink,\n  useEffectEvent,\n  useGlobalListeners,\n  useSyncRef\n} from '@react-aria/utils';\nimport {createSyntheticEvent, preventFocus, setEventTarget} from './utils';\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents, RefObject} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {PressResponderContext} from './context';\nimport {MouseEvent as RMouseEvent, TouchEvent as RTouchEvent, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element | null>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>,\n  disposables: Array<() => void>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean,\n  clientX?: number,\n  clientY?: number,\n  targetTouches?: Array<{clientX?: number, clientY?: number}>\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  x: number;\n  y: number;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase, state?: PressState) {\n    let currentTarget = state?.target ?? originalEvent.currentTarget;\n    const rect: DOMRect | undefined = (currentTarget as Element)?.getBoundingClientRect();\n    let x, y = 0;\n    let clientX, clientY: number | null = null;\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    onClick,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    ref: domRef,\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let triggerClick = useEffectEvent((e: RMouseEvent<FocusableElement>) => {\n    onClick?.(e);\n  });\n\n  let triggerSyntheticClick = useEffectEvent((e: KeyboardEvent | TouchEvent, target: FocusableElement) => {\n    // Some third-party libraries pass in onClick instead of onPress.\n    // Create a fake mouse event and trigger onClick as well.\n    // This matches the browser's native activation behavior for certain elements (e.g. button).\n    // https://html.spec.whatwg.org/#activation\n    // https://html.spec.whatwg.org/#fire-a-synthetic-pointer-event\n    if (onClick) {\n      let event = new MouseEvent('click', e);\n      setEventTarget(event, target);\n      onClick(createSyntheticEvent(event));\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          if (shouldPreventDefaultKeyboard(getEventTarget(e.nativeEvent), e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = (e) => {\n              if (isValidKeyboardEvent(e, originalTarget) && !e.repeat && nodeContains(originalTarget, getEventTarget(e)) && state.target) {\n                triggerPressUp(createEvent(state.target, e), 'keyboard');\n              }\n            };\n\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', chain(pressUp, onKeyUp), true);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onClick(e) {\n        if (e && !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n          \n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            let pointerType = state.pointerType || (e.nativeEvent as PointerEvent).pointerType as PointerType || 'virtual';\n            shouldStopPropagation = triggerPressEnd(createEvent(e.currentTarget, e), pointerType, true);\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(getEventTarget(e), e.key)) {\n          e.preventDefault();\n        }\n\n        let target = getEventTarget(e);\n        let wasPressed = nodeContains(state.target, getEventTarget(e));\n        triggerPressEnd(createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) {\n          triggerSyntheticClick(e, state.target);\n        }\n        removeAllGlobalListeners();\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && nodeContains(state.target, target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget as FocusableElement;\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          // Release pointer capture so that touch interactions can leave the original target.\n          // This enables onPointerLeave and onPointerEnter to fire.\n          let target = getEventTarget(e.nativeEvent);\n          if ('releasePointerCapture' in target) {\n            target.releasePointerCapture(e.pointerId);\n          }\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            let dispose = preventFocus(e.target as FocusableElement);\n            if (dispose) {\n              state.disposables.push(dispose);\n            }\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent)) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks\n        if (e.button === 0) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      pressProps.onPointerEnter = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart(createEvent(state.target, e), state.pointerType);\n        }\n      };\n\n      pressProps.onPointerLeave = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (nodeContains(state.target, getEventTarget(e)) && state.pointerType != null) {\n            // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n            // is mutated between onPointerUp and onClick, and is more compatible with third party libraries.\n            // https://github.com/adobe/react-spectrum/issues/1513\n            // https://issues.chromium.org/issues/40732224\n            // However, iOS and Android do not focus or fire onClick after a long press.\n            // We work around this by triggering a click ourselves after a timeout.\n            // This timeout is canceled during the click event in case the real one fires first.\n            // The timeout must be at least 32ms, because Safari on iOS delays the click event on\n            // non-form elements without certain ARIA roles (for hover emulation).\n            // https://github.com/WebKit/WebKit/blob/dccfae42bb29bd4bdef052e469f604a9387241c0/Source/WebKit/WebProcess/WebPage/ios/WebPageIOS.mm#L875-L892\n            let clicked = false;\n            let timeout = setTimeout(() => {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) {\n                  cancel(e);\n                } else {\n                  focusWithoutScrolling(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80);\n            // Use a capturing listener to track if a click occurred.\n            // If stopPropagation is called it may never reach our handler.\n            addGlobalListener(e.currentTarget as Document, 'click', () => clicked = true, true);\n            state.disposables.push(() => clearTimeout(timeout));\n          } else {\n            cancel(e);\n          }\n\n          // Ignore subsequent onPointerLeave event before onClick on touch devices.\n          state.isOverTarget = false;\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      // NOTE: this fallback branch is entirely used by unit tests.\n      // All browsers now support pointer events, but JSDOM still does not.\n\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        // Flush sync so that focus moved during react re-renders occurs before we yield back to the browser.\n        let shouldStopPropagation = flushSync(() => triggerPressStart(e, state.pointerType!));\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        if (preventFocusOnPress) {\n          let dispose = preventFocus(e.target as FocusableElement);\n          if (dispose) {\n            state.disposables.push(dispose);\n          }\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && state.target.contains(e.target as Element) && state.pointerType != null) {\n          // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n          // is mutated between onMouseUp and onClick, and is more compatible with third party libraries.\n        } else {\n          cancel(e);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(createTouchEvent(state.target!, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n          cancelOnPointerExit(createTouchEvent(state.target!, e));\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(createTouchEvent(state.target!, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target!);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(createTouchEvent(state.target!, e));\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && nodeContains(getEventTarget(e), state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp,\n    triggerClick,\n    triggerSyntheticClick\n  ]);\n\n  // Avoid onClick delay for double tap to zoom by default.\n  useEffect(() => {\n    let element = domRef?.current;\n    if (element && (element instanceof getOwnerWindow(element).Element)) {\n      // Only apply touch-action if not already set by another CSS rule.\n      let style = getOwnerWindow(element).getComputedStyle(element);\n      if (style.touchAction === 'auto') {\n        // touchAction: 'manipulation' is supposed to be equivalent, but in \n        // Safari it causes onPointerCancel not to fire on scroll.\n        // https://bugs.webkit.org/show_bug.cgi?id=240917\n        (element as HTMLElement).style.touchAction = 'pan-x pan-y pinch-zoom';\n      }\n    }\n  }, [domRef]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  useEffect(() => {\n    let state = ref.current;\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target ?? undefined);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps)\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createTouchEvent(target: FocusableElement, e: RTouchEvent<FocusableElement>): EventBase {\n  let clientX = 0;\n  let clientY = 0;\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  let clientX = e.clientX;\n  let clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefaultUp(target: Element) {\n  if (target instanceof HTMLInputElement) {\n    return false;\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  return shouldPreventDefaultUp(target);\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n"]},"metadata":{},"sourceType":"module"}
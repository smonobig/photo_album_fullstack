{"ast":null,"code":"import { useEffectEvent as $ispOf$useEffectEvent, getOwnerDocument as $ispOf$getOwnerDocument } from \"@react-aria/utils\";\nimport { useRef as $ispOf$useRef, useEffect as $ispOf$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n  let {\n    ref: ref,\n    onInteractOutside: onInteractOutside,\n    isDisabled: isDisabled,\n    onInteractOutsideStart: onInteractOutsideStart\n  } = props;\n  let stateRef = (0, $ispOf$useRef)({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n  let onPointerDown = (0, $ispOf$useEffectEvent)(e => {\n    if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) onInteractOutsideStart(e);\n      stateRef.current.isPointerDown = true;\n    }\n  });\n  let triggerInteractOutside = (0, $ispOf$useEffectEvent)(e => {\n    if (onInteractOutside) onInteractOutside(e);\n  });\n  (0, $ispOf$useEffect)(() => {\n    let state = stateRef.current;\n    if (isDisabled) return;\n    const element = ref.current;\n    const documentObject = (0, $ispOf$getOwnerDocument)(element);\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== 'undefined') {\n      let onPointerUp = e => {\n        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      // changing these to capture phase fixed combobox\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('pointerup', onPointerUp, true);\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('pointerup', onPointerUp, true);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      let onMouseUp = e => {\n        if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      let onTouchEnd = e => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n  if (event.button > 0) return false;\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest('[data-react-aria-top-layer]')) return false;\n  }\n  if (!ref.current) return false;\n  // When the event source is inside a Shadow DOM, event.target is just the shadow root.\n  // Using event.composedPath instead means we can get the actual element inside the shadow root.\n  // This only works if the shadow root is open, there is no way to detect if it is closed.\n  // If the event composed path contains the ref, interaction is inside.\n  return !event.composedPath().includes(ref.current);\n}\nexport { $e0b6e0b68ec7f50f$export$872b660ac5a1ff98 as useInteractOutside };","map":{"version":3,"sources":["packages/@react-aria/interactions/src/useInteractOutside.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, useEffectEvent} from '@react-aria/utils';\nimport {RefObject} from '@react-types/shared';\nimport {useEffect, useRef} from 'react';\n\nexport interface InteractOutsideProps {\n  ref: RefObject<Element | null>,\n  onInteractOutside?: (e: PointerEvent) => void,\n  onInteractOutsideStart?: (e: PointerEvent) => void,\n  /** Whether the interact outside events should be disabled. */\n  isDisabled?: boolean\n}\n\n/**\n * Example, used in components like Dialogs and Popovers so they can close\n * when a user clicks outside them.\n */\nexport function useInteractOutside(props: InteractOutsideProps): void {\n  let {ref, onInteractOutside, isDisabled, onInteractOutsideStart} = props;\n  let stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n\n  let onPointerDown = useEffectEvent((e) => {\n    if (onInteractOutside && isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) {\n        onInteractOutsideStart(e);\n      }\n      stateRef.current.isPointerDown = true;\n    }\n  });\n\n  let triggerInteractOutside = useEffectEvent((e: PointerEvent) => {\n    if (onInteractOutside) {\n      onInteractOutside(e);\n    }\n  });\n\n  useEffect(() => {\n    let state = stateRef.current;\n    if (isDisabled) {\n      return;\n    }\n\n    const element = ref.current;\n    const documentObject = getOwnerDocument(element);\n\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== 'undefined') {\n      let onPointerUp = (e) => {\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      // changing these to capture phase fixed combobox\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('pointerup', onPointerUp, true);\n\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('pointerup', onPointerUp, true);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      let onMouseUp = (e) => {\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n        } else if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      let onTouchEnd = (e) => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\n\nfunction isValidEvent(event, ref) {\n  if (event.button > 0) {\n    return false;\n  }\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) {\n      return false;\n    }\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest('[data-react-aria-top-layer]')) {\n      return false;\n    }\n  }\n\n  if (!ref.current) {\n    return false;\n  }\n\n  // When the event source is inside a Shadow DOM, event.target is just the shadow root.\n  // Using event.composedPath instead means we can get the actual element inside the shadow root.\n  // This only works if the shadow root is open, there is no way to detect if it is closed.\n  // If the event composed path contains the ref, interaction is inside.\n  return !event.composedPath().includes(ref.current);\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { useGlobalListeners as $AWxnT$useGlobalListeners, getOwnerDocument as $AWxnT$getOwnerDocument, nodeContains as $AWxnT$nodeContains } from \"@react-aria/utils\";\nimport { useState as $AWxnT$useState, useRef as $AWxnT$useRef, useEffect as $AWxnT$useEffect, useMemo as $AWxnT$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(() => {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') return;\n  if (typeof PointerEvent !== 'undefined') document.addEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);else if (process.env.NODE_ENV === 'test') document.addEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  $6179b936705e76d3$var$hoverCount++;\n  return () => {\n    $6179b936705e76d3$var$hoverCount--;\n    if ($6179b936705e76d3$var$hoverCount > 0) return;\n    if (typeof PointerEvent !== 'undefined') document.removeEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);else if (process.env.NODE_ENV === 'test') document.removeEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n  let {\n    onHoverStart: onHoverStart,\n    onHoverChange: onHoverChange,\n    onHoverEnd: onHoverEnd,\n    isDisabled: isDisabled\n  } = props;\n  let [isHovered, setHovered] = (0, $AWxnT$useState)(false);\n  let state = (0, $AWxnT$useRef)({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n  (0, $AWxnT$useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $AWxnT$useGlobalListeners)();\n  let {\n    hoverProps: hoverProps,\n    triggerHoverEnd: triggerHoverEnd\n  } = (0, $AWxnT$useMemo)(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) return;\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n      // When an element that is hovered over is removed, no pointerleave event is fired by the browser,\n      // even though the originally hovered target may have shrunk in size so it is no longer hovered.\n      // However, a pointerover event will be fired on the new target the mouse is over.\n      // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.\n      addGlobalListener((0, $AWxnT$getOwnerDocument)(event.target), 'pointerover', e => {\n        if (state.isHovered && state.target && !(0, $AWxnT$nodeContains)(state.target, e.target)) triggerHoverEnd(e, e.pointerType);\n      }, {\n        capture: true\n      });\n      if (onHoverStart) onHoverStart({\n        type: 'hoverstart',\n        target: target,\n        pointerType: pointerType\n      });\n      if (onHoverChange) onHoverChange(true);\n      setHovered(true);\n    };\n    let triggerHoverEnd = (event, pointerType) => {\n      let target = state.target;\n      state.pointerType = '';\n      state.target = null;\n      if (pointerType === 'touch' || !state.isHovered || !target) return;\n      state.isHovered = false;\n      removeAllGlobalListeners();\n      if (onHoverEnd) onHoverEnd({\n        type: 'hoverend',\n        target: target,\n        pointerType: pointerType\n      });\n      if (onHoverChange) onHoverChange(false);\n      setHovered(false);\n    };\n    let hoverProps = {};\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = e => {\n        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') return;\n        triggerHoverStart(e, e.pointerType);\n      };\n      hoverProps.onPointerLeave = e => {\n        if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n      hoverProps.onMouseEnter = e => {\n        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, 'mouse');\n        state.ignoreEmulatedMouseEvents = false;\n      };\n      hoverProps.onMouseLeave = e => {\n        if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, 'mouse');\n      };\n    }\n    return {\n      hoverProps: hoverProps,\n      triggerHoverEnd: triggerHoverEnd\n    };\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state, addGlobalListener, removeAllGlobalListeners]);\n  (0, $AWxnT$useEffect)(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) triggerHoverEnd({\n      currentTarget: state.target\n    }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n  return {\n    hoverProps: hoverProps,\n    isHovered: isHovered\n  };\n}\nexport { $6179b936705e76d3$export$ae780daf29e6d456 as useHover };","map":{"version":3,"sources":["packages/@react-aria/interactions/src/useHover.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, HoverEvents} from '@react-types/shared';\nimport {getOwnerDocument, nodeContains, useGlobalListeners} from '@react-aria/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface HoverProps extends HoverEvents {\n  /** Whether the hover events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface HoverResult {\n  /** Props to spread on the target element. */\n  hoverProps: DOMAttributes,\n  isHovered: boolean\n}\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet globalIgnoreEmulatedMouseEvents = false;\nlet hoverCount = 0;\n\nfunction setGlobalIgnoreEmulatedMouseEvents() {\n  globalIgnoreEmulatedMouseEvents = true;\n\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(() => {\n    globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\n\nfunction handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') {\n    setGlobalIgnoreEmulatedMouseEvents();\n  }\n}\n\nfunction setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerup', handleGlobalPointerEvent);\n  } else if (process.env.NODE_ENV === 'test') {\n    document.addEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n  }\n\n  hoverCount++;\n  return () => {\n    hoverCount--;\n    if (hoverCount > 0) {\n      return;\n    }\n\n    if (typeof PointerEvent !== 'undefined') {\n      document.removeEventListener('pointerup', handleGlobalPointerEvent);\n    } else if (process.env.NODE_ENV === 'test') {\n      document.removeEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n    }\n  };\n}\n\n/**\n * Handles pointer hover interactions for an element. Normalizes behavior\n * across browsers and platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useHover(props: HoverProps): HoverResult {\n  let {\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled\n  } = props;\n\n  let [isHovered, setHovered] = useState(false);\n  let state = useRef({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n\n  useEffect(setupGlobalTouchEvents, []);\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let {hoverProps, triggerHoverEnd} = useMemo(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) {\n        return;\n      }\n\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n\n      // When an element that is hovered over is removed, no pointerleave event is fired by the browser,\n      // even though the originally hovered target may have shrunk in size so it is no longer hovered.\n      // However, a pointerover event will be fired on the new target the mouse is over.\n      // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.\n      addGlobalListener(getOwnerDocument(event.target), 'pointerover', e => {\n        if (state.isHovered && state.target && !nodeContains(state.target, e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      }, {capture: true});\n\n      if (onHoverStart) {\n        onHoverStart({\n          type: 'hoverstart',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(true);\n      }\n\n      setHovered(true);\n    };\n\n    let triggerHoverEnd = (event, pointerType) => {\n      let target = state.target;\n      state.pointerType = '';\n      state.target = null;\n\n      if (pointerType === 'touch' || !state.isHovered || !target) {\n        return;\n      }\n\n      state.isHovered = false;\n      removeAllGlobalListeners();\n\n      if (onHoverEnd) {\n        onHoverEnd({\n          type: 'hoverend',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(false);\n      }\n\n      setHovered(false);\n    };\n\n    let hoverProps: DOMAttributes = {};\n\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = (e) => {\n        if (globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') {\n          return;\n        }\n\n        triggerHoverStart(e, e.pointerType);\n      };\n\n      hoverProps.onPointerLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n\n      hoverProps.onMouseEnter = (e) => {\n        if (!state.ignoreEmulatedMouseEvents && !globalIgnoreEmulatedMouseEvents) {\n          triggerHoverStart(e, 'mouse');\n        }\n\n        state.ignoreEmulatedMouseEvents = false;\n      };\n\n      hoverProps.onMouseLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, 'mouse');\n        }\n      };\n    }\n    return {hoverProps, triggerHoverEnd};\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state, addGlobalListener, removeAllGlobalListeners]);\n\n  useEffect(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) {\n      triggerHoverEnd({currentTarget: state.target}, state.pointerType);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n\n  return {\n    hoverProps,\n    isHovered\n  };\n}\n"]},"metadata":{},"sourceType":"module"}
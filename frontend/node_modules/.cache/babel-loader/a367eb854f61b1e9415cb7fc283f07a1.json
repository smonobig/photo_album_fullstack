{"ast":null,"code":"import { nodeContains as $d4ee10de306f2510$export$4282f70798064fe0 } from \"./DOMFunctions.module.js\";\nimport { shadowDOM as $bJKXg$shadowDOM } from \"@react-stately/flags\";\n\n// https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/ShadowTreeWalker.ts\n\nclass $dfc540311bf7f109$export$63eb3ababa9c55c4 {\n  get currentNode() {\n    return this._currentNode;\n  }\n  set currentNode(node) {\n    if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(this.root, node)) throw new Error('Cannot set currentNode to a node that is not contained by the root node.');\n    const walkers = [];\n    let curNode = node;\n    let currentWalkerCurrentNode = node;\n    this._currentNode = node;\n    while (curNode && curNode !== this.root) if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      const shadowRoot = curNode;\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      walkers.push(walker);\n      walker.currentNode = currentWalkerCurrentNode;\n      this._currentSetFor.add(walker);\n      curNode = currentWalkerCurrentNode = shadowRoot.host;\n    } else curNode = curNode.parentNode;\n    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n      acceptNode: this._acceptNode\n    });\n    walkers.push(walker);\n    walker.currentNode = currentWalkerCurrentNode;\n    this._currentSetFor.add(walker);\n    this._walkerStack = walkers;\n  }\n  get doc() {\n    return this._doc;\n  }\n  firstChild() {\n    let currentNode = this.currentNode;\n    let newNode = this.nextNode();\n    if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(currentNode, newNode)) {\n      this.currentNode = currentNode;\n      return null;\n    }\n    if (newNode) this.currentNode = newNode;\n    return newNode;\n  }\n  lastChild() {\n    let walker = this._walkerStack[0];\n    let newNode = walker.lastChild();\n    if (newNode) this.currentNode = newNode;\n    return newNode;\n  }\n  nextNode() {\n    const nextNode = this._walkerStack[0].nextNode();\n    if (nextNode) {\n      const shadowRoot = nextNode.shadowRoot;\n      if (shadowRoot) {\n        var _this_filter;\n        let nodeResult;\n        if (typeof this.filter === 'function') nodeResult = this.filter(nextNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(nextNode);\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          this.currentNode = nextNode;\n          return nextNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.nextNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      }\n      if (nextNode) this.currentNode = nextNode;\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        let newNode = this.nextNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      } else return null;\n    }\n  }\n  previousNode() {\n    const currentWalker = this._walkerStack[0];\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          let newNode = this.previousNode();\n          if (newNode) this.currentNode = newNode;\n          return newNode;\n        } else return null;\n      }\n      return null;\n    }\n    const previousNode = currentWalker.previousNode();\n    if (previousNode) {\n      const shadowRoot = previousNode.shadowRoot;\n      if (shadowRoot) {\n        var _this_filter;\n        let nodeResult;\n        if (typeof this.filter === 'function') nodeResult = this.filter(previousNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(previousNode);\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          if (previousNode) this.currentNode = previousNode;\n          return previousNode;\n        }\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.lastChild();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      }\n      if (previousNode) this.currentNode = previousNode;\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n        let newNode = this.previousNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      } else return null;\n    }\n  }\n  /**\n   * @deprecated\n   */\n  nextSibling() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n  /**\n   * @deprecated\n   */\n  previousSibling() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n  /**\n   * @deprecated\n   */\n  parentNode() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n  constructor(doc, root, whatToShow, filter) {\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n    this._acceptNode = node => {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const shadowRoot = node.shadowRoot;\n        if (shadowRoot) {\n          const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n            acceptNode: this._acceptNode\n          });\n          this._walkerStack.unshift(walker);\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          var _this_filter;\n          if (typeof this.filter === 'function') return this.filter(node);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) return this.filter.acceptNode(node);else if (this.filter === null) return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n      return NodeFilter.FILTER_SKIP;\n    };\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n    const shadowRoot = root.shadowRoot;\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n      this._walkerStack.unshift(walker);\n    }\n  }\n}\nfunction $dfc540311bf7f109$export$4d0f8be8b12a7ef6(doc, root, whatToShow, filter) {\n  if ((0, $bJKXg$shadowDOM)()) return new $dfc540311bf7f109$export$63eb3ababa9c55c4(doc, root, whatToShow, filter);\n  return doc.createTreeWalker(root, whatToShow, filter);\n}\nexport { $dfc540311bf7f109$export$63eb3ababa9c55c4 as ShadowTreeWalker, $dfc540311bf7f109$export$4d0f8be8b12a7ef6 as createShadowTreeWalker };","map":{"version":3,"sources":["packages/@react-aria/utils/src/shadowdom/ShadowTreeWalker.ts"],"names":[],"mappings":"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","sourcesContent":["// https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/ShadowTreeWalker.ts\n\nimport {nodeContains} from './DOMFunctions';\nimport {shadowDOM} from '@react-stately/flags';\n\nexport class ShadowTreeWalker implements TreeWalker {\n  public readonly filter: NodeFilter | null;\n  public readonly root: Node;\n  public readonly whatToShow: number;\n\n  private _doc: Document;\n  private _walkerStack: Array<TreeWalker> = [];\n  private _currentNode: Node;\n  private _currentSetFor: Set<TreeWalker> = new Set();\n\n  constructor(\n      doc: Document,\n      root: Node,\n      whatToShow?: number,\n      filter?: NodeFilter | null\n    ) {\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter ?? null;\n    this.whatToShow = whatToShow ?? NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n\n    this._walkerStack.unshift(\n      doc.createTreeWalker(root, whatToShow, this._acceptNode)\n    );\n\n    const shadowRoot = (root as Element).shadowRoot;\n\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(\n        shadowRoot,\n        this.whatToShow,\n        {acceptNode: this._acceptNode}\n      );\n\n      this._walkerStack.unshift(walker);\n    }\n  }\n\n  private _acceptNode = (node: Node): number => {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const shadowRoot = (node as Element).shadowRoot;\n\n      if (shadowRoot) {\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        this._walkerStack.unshift(walker);\n\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        if (typeof this.filter === 'function') {\n          return this.filter(node);\n        } else if (this.filter?.acceptNode) {\n          return this.filter.acceptNode(node);\n        } else if (this.filter === null) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  };\n\n  public get currentNode(): Node {\n    return this._currentNode;\n  }\n\n  public set currentNode(node: Node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\n        'Cannot set currentNode to a node that is not contained by the root node.'\n      );\n    }\n\n    const walkers: TreeWalker[] = [];\n    let curNode: Node | null | undefined = node;\n    let currentWalkerCurrentNode = node;\n\n    this._currentNode = node;\n\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode as ShadowRoot;\n\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        walkers.push(walker);\n\n        walker.currentNode = currentWalkerCurrentNode;\n\n        this._currentSetFor.add(walker);\n\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n\n    const walker = this._doc.createTreeWalker(\n      this.root,\n      this.whatToShow,\n      {acceptNode: this._acceptNode}\n    );\n\n    walkers.push(walker);\n\n    walker.currentNode = currentWalkerCurrentNode;\n\n    this._currentSetFor.add(walker);\n\n    this._walkerStack = walkers;\n  }\n\n  public get doc(): Document {\n    return this._doc;\n  }\n\n  public firstChild(): Node | null {\n    let currentNode = this.currentNode;\n    let newNode = this.nextNode();\n    if (!nodeContains(currentNode, newNode)) {\n      this.currentNode = currentNode;\n      return null;\n    }\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public lastChild(): Node | null {\n    let walker = this._walkerStack[0];\n    let newNode = walker.lastChild();\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public nextNode(): Node | null {\n    const nextNode = this._walkerStack[0].nextNode();\n\n    if (nextNode) {\n      const shadowRoot = (nextNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(nextNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          this.currentNode = nextNode;\n          return nextNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (nextNode) {\n        this.currentNode = nextNode;\n      }\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  public previousNode(): Node | null {\n    const currentWalker = this._walkerStack[0];\n\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          let newNode = this.previousNode();\n          if (newNode) {\n            this.currentNode = newNode;\n          }\n          return newNode;\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    }\n\n    const previousNode = currentWalker.previousNode();\n\n    if (previousNode) {\n      const shadowRoot = (previousNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(previousNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          if (previousNode) {\n            this.currentNode = previousNode;\n          }\n          return previousNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.lastChild();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (previousNode) {\n        this.currentNode = previousNode;\n      }\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.previousNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n    /**\n     * @deprecated\n     */\n  public nextSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public previousSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public parentNode(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n}\n\n/**\n * ShadowDOM safe version of document.createTreeWalker.\n */\nexport function createShadowTreeWalker(\n    doc: Document,\n    root: Node,\n    whatToShow?: number,\n    filter?: NodeFilter | null\n): TreeWalker {\n  if (shadowDOM()) {\n    return new ShadowTreeWalker(doc, root, whatToShow, filter);\n  }\n  return doc.createTreeWalker(root, whatToShow, filter);\n}\n"]},"metadata":{},"sourceType":"module"}